# -*- mode: autoconf; -*-
# ============================================================================ #
#
#
# ---------------------------------------------------------------------------- #

# _LTM_FS_FN_FUNC_LO2O_PREPARE
# ----------------------------
m4_defun_once([_LTM_FS_FN_FUNC_LO2O_PREPARE],
[
# func_lo2o OBJECT-NAME
# ---------------------
# Transform OBJECT-NAME from a '.lo' suffix to the platform specific
# object suffix.
lo2o=s/\\.lo\$[]/.$objext/
o2lo=s/\\.$objext\$[]/.lo/

if test yes = "$_G_HAVE_XSI_OPS"; then
  eval 'func_lo2o ()
  {
    case $[]1 in
      *.lo) func_lo2o_result=${1%.lo}.$objext ;;
      *   ) func_lo2o_result=$[]1               ;;
    esac
  }'
else
  # ...otherwise fall back to using sed.
  func_lo2o ()
  {
    func_lo2o_result=`$ECHO "$[]1" | $SED "$lo2o"`
  }
fi
])# _LTM_FS_FN_FUNC_LO2O_PREPARE


# LTM_FS_FN_FUNC_LO2O(FILENAME)
# -----------------------------
m4_defun_init([_LTM_FS_FN_FUNC_LO2O],
[func_lo2o $1],
[m4_require([_LTM_FS_FN_FUNC_LO2O_PREPARE])
func_lo2o $1
])# LTM_FS_FN_FUNC_LO2O


# ---------------------------------------------------------------------------- #

# _LTM_FS_FN_FUNC_XFORM_PREPARE
# -----------------------------
m4_defun_once([_LTM_FS_FN_FUNC_XFORM_PREPARE],
[
if test yes = "$_G_HAVE_XSI_OPS"; then
  # func_xform LIBOBJ-OR-SOURCE
  # ---------------------------
  # Transform LIBOBJ-OR-SOURCE from a '.o' or '.c' (or otherwise)
  # suffix to a '.lo' libtool-object suffix.
  eval 'func_xform ()
  {
    func_xform_result=${1%.*}.lo
  }'
else
  func_xform ()
  {
    func_xform_result=`$ECHO "$[]1" | $SED 's|\.[[^.]]*$[]|.lo|'`
  }
fi
])# _LTM_FS_FN_FUNC_XFORM_PREPARE


# LTM_FS_FN_FUNC_XFORM(FILENAME)
# ------------------------------
m4_defun_init([LTM_FS_FN_FUNC_XFORM],
[func_xform $1],
[m4_require([_LTM_FS_FN_FUNC_XFORM_PREPARE])
func_xform $1
])# LTM_FS_FN_FUNC_XFORM


# ---------------------------------------------------------------------------- #

# _LTM_FS_FN_GENERATED_BY_LT_P_PREPARE
# ------------------------------------
m4_defun_once([_LTM_FS_FN_GENERATED_BY_LT_P_PREPARE],
[
# func_generated_by_libtool
# True iff stdin has been generated by Libtool. This function is only
# a basic sanity check; it will hardly flush out determined imposters.
func_generated_by_libtool_p ()
{
  if test $[]# -gt 0
  then
    cat $[]-|$GREP "^# Generated by .*$PACKAGE" > /dev/null 2>&1
  else
    $GREP "^# Generated by .*$PACKAGE" $[]1 > /dev/null 2>&1
  fi
}
])# _LTM_FS_FN_GENERATED_BY_LT_P_PREPARE


# LTM_FS_FN_GENERATED_BY_LT_P(FILE)
# ---------------------------------
m4_defun_init([LTM_FS_FN_GENERATED_BY_LT_P],
[func_generated_by_libtool $1],
[m4_require([_LTM_FS_FN_GENERATED_BY_LT_P_PREPARE])
func_generated_by_libtool_p $1
])# LTM_FS_FN_GENERATED_BY_LT_P(FILE)


# ---------------------------------------------------------------------------- #

# _LTM_FS_FN_LALIB_P_PREPARE
# --------------------------
m4_defun_once([_LTM_FS_FN_LALIB_P_PREPARE],
[m4_require([_LTM_FS_FN_GENERATED_BY_LT_P_PREPARE])
# func_lalib_p file
# -----------------
# True iff FILE is a libtool '.la' library or '.lo' object file.
# This function is only a basic sanity check; it will hardly flush out
# determined imposters.
func_lalib_p ()
{
  test -f "$[]1" &&  \
    $SED -e 4q "$[]1" 2>/dev/null|func_generated_by_libtool_p
}
])# _LTM_FS_FN_LALIB_P_PREPARE


# LTM_FS_FN_LALIB_P(FILE)
# -----------------------
m4_defun_init([LTM_FS_FN_LALIB_P],
[func_lalib_p $1],
[m4_require([_LTM_FS_FN_LALIB_P_PREPARE])
func_lalib_p $1
])# LTM_FS_FN_LALIB_P


# ---------------------------------------------------------------------------- #

# _LTM_FS_FN_LALIB_UNSAFE_P_PREPARE
# ---------------------------------
m4_defun_once([_LTM_FS_FN_LALIB_UNSAFE_P_PREPARE],
[
# func_lalib_unsafe_p file
# True iff FILE is a libtool '.la' library or '.lo' object file.
# This function implements the same check as func_lalib_p without
# resorting to external programs.  To this end, it redirects stdin and
# closes it afterwards, without saving the original file descriptor.
# As a safety measure, use it only where a negative result would be
# fatal anyway.  Works if 'file' does not exist.
func_lalib_unsafe_p ()
{
  lalib_p=no
  if test -f "$[]1" && test -r "$[]1" && exec 5<&0 <"$[]1"; then
    for lalib_p_l in 1 2 3 4
    do
        read lalib_p_line
        case $lalib_p_line in
          \#\ Generated\ by\ *$PACKAGE* ) lalib_p=yes; break;;
        esac
    done
    exec 0<&5 5<&-
  fi
  test yes = "$lalib_p"
}
])# _LTM_FS_FN_LALIB_UNSAFE_P_PREPARE


# LTM_FS_FN_LALIB_UNSAFE_P(FILE)
# ------------------------------
m4_defun_init([LTM_FS_FN_LALIB_UNSAFE_P],
[func_lalib_unsafe_p $1],
[m4_require([_LTM_FS_FN_LALIB_UNSAFE_P_PREPARE])
func_lalib_unsafe_p $1
])# LTM_FS_FN_LALIB_UNSAFE_P(FILE)


# ---------------------------------------------------------------------------- #

# LTM_FS_INIT
# -----------
m4_defun_once([LTM_FS_INIT],
[m4_require([_LTM_FS_FN_FUNC_LO2O_PREPARE])
m4_require([_LTM_FS_FN_FUNC_XFORM_PREPARE])
m4_require([_LTM_FS_FN_GENERATED_BY_LT_P_PREPARE])
m4_require([_LTM_FS_FN_LALIB_P_PREPARE])
m4_require([_LTM_FS_FN_LALIB_UNSAFE_P_PREPARE])
m4_pattern_forbid([^_LTM_FS_])
])# LTM_FS_INIT


# ---------------------------------------------------------------------------- #



# ============================================================================ #
# vim: set filetype=config :
